# Документация по инструменту создания зашифрованных payload

Данный инструмент предназначен для шифрования и зашифровки вводимого текста (обычно это payload для атак) с использованием разнообразных методов кодирования. Это повышает скрытность и способность обходить системы обнаружения. Ниже приведён детальный анализ каждой функциональной части инструмента.

## Модуль основных кодировочных функций

### URL-кодирование
```python
def url_encode(line):
    return urllib.parse.quote(line)
```

**Принцип шифровки**:
- Специальные символы (например, пробелы, знаки препинания) в тексте преобразуются в соответствующие Unicode-коды
- Используется формат с百分号 кодирования (%XX), где XX — шестнадцатеричное значение символа
- Например, пробел преобразуется в `%20`, символ новой строки — в `%0A`
- Такое кодирование主要用于 сетевых передачах в параметрах URL, чтобы специальные символы не нарушали структуру протокола

### Преобразование регистра
```python
def case_convert(line):
    converted = []
    letter_count = 0
    for char in line:
        if char.isalpha():
            letter_count += 1
            converted.append(char.swapcase() if letter_count % 2 == 1 else char)
        else:
            converted.append(char)
    return ''.join(converted)
```

**Принцип шифровки**:
- Покайтерпельно обрабатываются буквенные символы текста
- В зависимости от четности позиции символа, регистр букв чередуется
- Например, "Payload" преобразуется в "PaYlOaD" и тому подобное
- Чередование регистра букв нарушает визуальную структуру слов, усложняя распознавание текста
- При этом не буквенные символы сохраняют свой первоначальный вид, чтобы保证 зашифрованный текст сохранял правильную синтаксическую структуру

### Base64-кодирование
```python
def base64_encode(line):
    return base64.b64encode(line.encode()).decode()
```

**Принцип шифровки**:
- Каждый байт разбивается на блоки по 6 бит,之后 эти блоки重新组合
- Используются 64 печатных символа (A-Z, a-z, 0-9, +, /) для представления этих блоков
- В конце добавляются символы равенства (=) для выравнивания длины данных
- Например, "Hello" будет закодировано как "SGVsbG8="
- Данный метод преобразует исходные данные в чистый текстовый формат, удобный для внедрения в разнообразные протоколы

### Преобразование в Unicode-экранирование
```python
def unicode_escape(line):
    escaped = []
    for char in line:
        cp = ord(char)
        if cp <= 0xFFFF:
            escaped.append(f"\\u{cp:04X}")
        else:
            escaped.append(f"\\U{cp:08X}")
    return ''.join(escaped)
```

**Принцип шифровки**:
- Каждый символ преобразуется в соответствующий Unicode-код
- Для символов в базовой мультилингвальной плоскости (BMP) используется формат `\uXXXX`
- Для символов вне BMP применяется формат `\UXXXXXXXX`
- Например, "A" (U+0041) преобразуется в `\u0041`
- Такое кодирование переводит символьное представление в чистый текстовый вид, что облегчает передачу и хранение данных в разных системах

### HTML-кодирование сущностей
```python
def html_encode(line):
    return html.escape(line, quote=True)
```

**Принцип шифровки**:
- Специальные символы преобразуются в соответствующие HTML-сущности
- Распространённые преобразования включают:
  - `<` → `&lt;`
  - `>` → `&gt;`
  - `&` → `&amp;`
  - `"` → `&quot;`
  - `'` → `&#x27;`
- Такое кодирование гарантирует правильную интерпретацию текста в HTML-среде, предотвращая его误识别为 HTML-теги
- Например, `<script>` будет преобразован в `&lt;script&gt;`

## Модуль списка кодировщиков
```python
ENCODERS = [
    ("url", url_encode),
    ("case", case_convert),
    ("base64", base64_encode),
    ("unicode", unicode_escape),
    ("html", html_encode)
]
```

Данный модуль определяет поддерживаемые типы кодирования и соответствующие им функции, что облегчает последующее быстрое вызов функций кодирования по имени.

## Примеры использования

### Режим полного кодирования
```bash
python3 Polymorphic.py input.txt output.txt
```

### Режим одиночного кодирования
```bash
python3 Polymorphic.py input.txt output.txt url
```
